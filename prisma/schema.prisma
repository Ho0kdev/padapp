// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================
// USUARIOS Y AUTENTICACIÓN (NextAuth)
// ============================================

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model User {
  id            String     @id @default(cuid())
  name          String?
  email         String     @unique
  emailVerified DateTime?
  image         String?
  password      String?
  role          UserRole   @default(PLAYER)
  status        UserStatus @default(ACTIVE)
  accounts      Account[]
  sessions      Session[]

  // Relaciones específicas del sistema
  player               Player?
  organizerTournaments Tournament[]   @relation("TournamentOrganizer")
  refereeMatches       Match[]        @relation("MatchReferee")
  notifications        Notification[]
  logs                 TournamentLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("users")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verificationtokens")
}

// ============================================
// ENUMS
// ============================================

enum UserRole {
  ADMIN
  CLUB_ADMIN
  PLAYER
  REFEREE
}

enum UserStatus {
  ACTIVE
  INACTIVE
  SUSPENDED
}

enum Gender {
  MALE
  FEMALE
  MIXED
}

enum DominantHand {
  RIGHT
  LEFT
  AMBIDEXTROUS
}

enum ClubStatus {
  ACTIVE
  INACTIVE
  MAINTENANCE
}

enum CourtSurface {
  CONCRETE
  ARTIFICIAL_GRASS
  CERAMIC
  OTHER
}

enum CourtStatus {
  AVAILABLE
  MAINTENANCE
  RESERVED
  UNAVAILABLE
}

enum CategoryType {
  AGE
  SKILL
  RANKING
  GENDER
  MIXED
}

enum TournamentType {
  SINGLE_ELIMINATION
  DOUBLE_ELIMINATION
  ROUND_ROBIN
  SWISS
  GROUP_STAGE_ELIMINATION
  AMERICANO
}

enum TournamentStatus {
  DRAFT
  PUBLISHED
  REGISTRATION_OPEN
  REGISTRATION_CLOSED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum TournamentVisibility {
  PUBLIC
  PRIVATE
  CLUB_MEMBERS
}

enum RegistrationStatus {
  PENDING
  CONFIRMED
  PAID
  CANCELLED
  WAITLIST
}

enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
}

enum PhaseType {
  GROUP_STAGE
  ROUND_OF_32
  ROUND_OF_16
  QUARTERFINALS
  SEMIFINALS
  FINAL
  THIRD_PLACE
}

enum MatchStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  WALKOVER
}

enum NotificationType {
  MATCH_SCHEDULED
  MATCH_RESULT
  TOURNAMENT_UPDATE
  PAYMENT_REMINDER
  REGISTRATION_CONFIRMED
}

enum NotificationStatus {
  PENDING
  SENT
  READ
  FAILED
}

// ============================================
// JUGADORES
// ============================================

model Player {
  id                    String        @id @default(cuid())
  userId                String        @unique
  firstName             String
  lastName              String
  phone                 String?
  dateOfBirth           DateTime?
  gender                Gender?
  dominantHand          DominantHand?
  profileImageUrl       String?
  emergencyContactName  String?
  emergencyContactPhone String?
  medicalNotes          String?
  rankingPoints         Int           @default(0)

  // Relaciones
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  team1Memberships Team[]            @relation("TeamPlayer1")
  team2Memberships Team[]            @relation("TeamPlayer2")
  rankings         PlayerRanking[]
  tournamentStats  TournamentStats[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("players")
}

// ============================================
// CLUBES Y CANCHAS
// ============================================

model Club {
  id          String     @id @default(cuid())
  name        String
  description String?
  address     String
  city        String
  state       String?
  country     String
  postalCode  String?
  phone       String?
  email       String?
  website     String?
  latitude    Float?
  longitude   Float?
  status      ClubStatus @default(ACTIVE)
  logoUrl     String?

  // Relaciones
  courts          Court[]
  tournaments     Tournament[]     @relation("TournamentMainClub")
  tournamentClubs TournamentClub[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("clubs")
}

model Court {
  id                String       @id @default(cuid())
  clubId            String
  name              String
  surface           CourtSurface
  hasLighting       Boolean      @default(false)
  hasRoof           Boolean      @default(false)
  isOutdoor         Boolean      @default(false)
  hasPanoramicGlass Boolean      @default(false)
  hasConcreteWall   Boolean      @default(false)
  hasNet4m          Boolean      @default(false)
  status            CourtStatus  @default(AVAILABLE)
  hourlyRate        Float?
  notes             String?

  // Relaciones
  club    Club    @relation(fields: [clubId], references: [id], onDelete: Cascade)
  matches Match[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("courts")
}

// ============================================
// CATEGORÍAS Y RANKING
// ============================================

model Category {
  id                String       @id @default(cuid())
  name              String
  description       String?
  type              CategoryType
  minAge            Int?
  maxAge            Int?
  genderRestriction Gender?
  minRankingPoints  Int?
  maxRankingPoints  Int?
  isActive          Boolean      @default(true)

  // Relaciones
  tournamentCategories TournamentCategory[]
  teams                Team[]
  matches              Match[]
  zones                TournamentZone[]
  rankings             PlayerRanking[]

  createdAt DateTime @default(now())

  @@map("categories")
}

model PlayerRanking {
  id            String   @id @default(cuid())
  playerId      String
  categoryId    String
  currentPoints Int      @default(0)
  position      Int?
  seasonYear    Int
  lastUpdated   DateTime @default(now())

  // Relaciones
  player   Player   @relation(fields: [playerId], references: [id], onDelete: Cascade)
  category Category @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  @@unique([playerId, categoryId, seasonYear])
  @@map("player_rankings")
}

// ============================================
// TORNEOS
// ============================================

model Tournament {
  id          String               @id @default(cuid())
  name        String
  description String?
  type        TournamentType
  status      TournamentStatus     @default(DRAFT)
  visibility  TournamentVisibility @default(PUBLIC)

  // Fechas
  registrationStart DateTime?
  registrationEnd   DateTime?
  tournamentStart   DateTime
  tournamentEnd     DateTime?

  // Configuración
  maxParticipants Int?
  minParticipants Int   @default(4)
  registrationFee Float @default(0)
  prizePool       Float @default(0)

  // Formato del juego
  setsToWin     Int     @default(2)
  gamesToWinSet Int     @default(6)
  tiebreakAt    Int     @default(6)
  goldenPoint   Boolean @default(true)

  // Organización
  organizerId String
  mainClubId  String?

  // Metadata
  rules             String?
  prizesDescription String?
  logoUrl           String?

  // Relaciones
  organizer     User                 @relation("TournamentOrganizer", fields: [organizerId], references: [id])
  mainClub      Club?                @relation("TournamentMainClub", fields: [mainClubId], references: [id])
  categories    TournamentCategory[]
  clubs         TournamentClub[]
  teams         Team[]
  matches       Match[]
  zones         TournamentZone[]
  stats         TournamentStats[]
  notifications Notification[]
  logs          TournamentLog[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("tournaments")
}

model TournamentClub {
  tournamentId String
  clubId       String

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  club       Club       @relation(fields: [clubId], references: [id], onDelete: Cascade)

  @@id([tournamentId, clubId])
  @@map("tournament_clubs")
}

model TournamentCategory {
  id              String @id @default(cuid())
  tournamentId    String
  categoryId      String
  maxTeams        Int?
  registrationFee Float?
  prizePool       Float?

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  teams      Team[]

  @@unique([tournamentId, categoryId])
  @@map("tournament_categories")
}

// ============================================
// EQUIPOS E INSCRIPCIONES
// ============================================

model Team {
  id                 String             @id @default(cuid())
  tournamentId       String
  categoryId         String
  name               String?
  player1Id          String
  player2Id          String
  registrationStatus RegistrationStatus @default(PENDING)
  registeredAt       DateTime           @default(now())
  seed               Int?
  notes              String?

  // Relaciones
  tournament         Tournament         @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  category           Category           @relation(fields: [categoryId], references: [id])
  tournamentCategory TournamentCategory @relation(fields: [tournamentId, categoryId], references: [tournamentId, categoryId])
  player1            Player             @relation("TeamPlayer1", fields: [player1Id], references: [id])
  player2            Player             @relation("TeamPlayer2", fields: [player2Id], references: [id])
  payments           TeamPayment[]
  zoneTeams          ZoneTeam[]

  // Partidos como team1 y team2
  team1Matches Match[] @relation("MatchTeam1")
  team2Matches Match[] @relation("MatchTeam2")
  wonMatches   Match[] @relation("MatchWinner")

  // Sets ganados
  wonSets  MatchSet[]  @relation("SetWinner")
  wonGames MatchGame[] @relation("GameWinner")

  @@map("teams")
}

model TeamPayment {
  id            String        @id @default(cuid())
  teamId        String
  amount        Float
  paymentStatus PaymentStatus @default(PENDING)
  paymentMethod String?
  transactionId String?
  paidAt        DateTime?

  // Relaciones
  team Team @relation(fields: [teamId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@map("team_payments")
}

// ============================================
// ZONAS/GRUPOS
// ============================================

model TournamentZone {
  id           String    @id @default(cuid())
  tournamentId String
  categoryId   String
  name         String
  phaseType    PhaseType @default(GROUP_STAGE)

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  category   Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  teams      ZoneTeam[]
  matches    Match[]

  @@map("tournament_zones")
}

model ZoneTeam {
  zoneId   String
  teamId   String
  position Int?

  // Relaciones
  zone TournamentZone @relation(fields: [zoneId], references: [id], onDelete: Cascade)
  team Team           @relation(fields: [teamId], references: [id], onDelete: Cascade)

  @@id([zoneId, teamId])
  @@map("zone_teams")
}

// ============================================
// PARTIDOS
// ============================================

model Match {
  id           String  @id @default(cuid())
  tournamentId String
  categoryId   String
  zoneId       String?

  // Equipos
  team1Id      String?
  team2Id      String?
  winnerTeamId String?

  // Programación
  scheduledAt DateTime?
  courtId     String?

  // Estado
  status      MatchStatus @default(SCHEDULED)
  phaseType   PhaseType
  roundNumber Int?
  matchNumber Int?

  // Resultados
  team1SetsWon    Int  @default(0)
  team2SetsWon    Int  @default(0)
  durationMinutes Int?

  // Árbitros
  refereeId String?
  notes     String?

  // Para eliminatorias
  team1FromMatchId String?
  team2FromMatchId String?

  // Relaciones
  tournament Tournament      @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  category   Category        @relation(fields: [categoryId], references: [id])
  zone       TournamentZone? @relation(fields: [zoneId], references: [id])
  team1      Team?           @relation("MatchTeam1", fields: [team1Id], references: [id])
  team2      Team?           @relation("MatchTeam2", fields: [team2Id], references: [id])
  winnerTeam Team?           @relation("MatchWinner", fields: [winnerTeamId], references: [id])
  court      Court?          @relation(fields: [courtId], references: [id])
  referee    User?           @relation("MatchReferee", fields: [refereeId], references: [id])

  sets             MatchSet[]
  team1FromMatch   Match?         @relation("MatchProgression1", fields: [team1FromMatchId], references: [id])
  team2FromMatch   Match?         @relation("MatchProgression2", fields: [team2FromMatchId], references: [id])
  nextMatchesTeam1 Match[]        @relation("MatchProgression1")
  nextMatchesTeam2 Match[]        @relation("MatchProgression2")
  notifications    Notification[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("matches")
}

model MatchSet {
  id                  String    @id @default(cuid())
  matchId             String
  setNumber           Int
  team1Games          Int       @default(0)
  team2Games          Int       @default(0)
  team1TiebreakPoints Int?
  team2TiebreakPoints Int?
  winnerTeamId        String?
  completedAt         DateTime?

  // Relaciones
  match      Match       @relation(fields: [matchId], references: [id], onDelete: Cascade)
  winnerTeam Team?       @relation("SetWinner", fields: [winnerTeamId], references: [id])
  games      MatchGame[]

  @@unique([matchId, setNumber])
  @@map("match_sets")
}

model MatchGame {
  id           String    @id @default(cuid())
  setId        String
  gameNumber   Int
  team1Points  Int       @default(0)
  team2Points  Int       @default(0)
  winnerTeamId String?
  isTiebreak   Boolean   @default(false)
  completedAt  DateTime?

  // Relaciones
  set        MatchSet @relation(fields: [setId], references: [id], onDelete: Cascade)
  winnerTeam Team?    @relation("GameWinner", fields: [winnerTeamId], references: [id])

  @@unique([setId, gameNumber])
  @@map("match_games")
}

// ============================================
// ESTADÍSTICAS
// ============================================

model TournamentStats {
  id            String @id @default(cuid())
  tournamentId  String
  playerId      String
  matchesPlayed Int    @default(0)
  matchesWon    Int    @default(0)
  setsWon       Int    @default(0)
  setsLost      Int    @default(0)
  gamesWon      Int    @default(0)
  gamesLost     Int    @default(0)
  pointsEarned  Int    @default(0)
  finalPosition Int?

  // Relaciones
  tournament Tournament @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  player     Player     @relation(fields: [playerId], references: [id], onDelete: Cascade)

  @@unique([tournamentId, playerId])
  @@map("tournament_stats")
}

// ============================================
// NOTIFICACIONES
// ============================================

model Notification {
  id           String             @id @default(cuid())
  userId       String
  tournamentId String?
  matchId      String?
  type         NotificationType
  title        String
  message      String
  status       NotificationStatus @default(PENDING)
  sentAt       DateTime?
  readAt       DateTime?

  // Relaciones
  user       User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  tournament Tournament? @relation(fields: [tournamentId], references: [id])
  match      Match?      @relation(fields: [matchId], references: [id])

  createdAt DateTime @default(now())

  @@map("notifications")
}

// ============================================
// AUDIT LOG / LOGS DE AUDITORIA
// ============================================

enum LogAction {
  TOURNAMENT_CREATED
  TOURNAMENT_UPDATED
  TOURNAMENT_DELETED
  TOURNAMENT_STATUS_CHANGED
  TEAM_REGISTERED
  TEAM_UNREGISTERED
  MATCH_CREATED
  MATCH_UPDATED
  MATCH_RESULT_ADDED
  USER_ACTION
}

model TournamentLog {
  id           String    @id @default(cuid())

  // Información del evento
  action       LogAction
  description  String    // Descripción human-readable del evento

  // Contexto del evento
  tournamentId String?
  userId       String    // Usuario que realizó la acción
  ipAddress    String?   // IP desde donde se realizó la acción
  userAgent    String?   // User Agent del navegador

  // Datos del evento
  oldData      Json?     // Estado anterior (para updates)
  newData      Json?     // Estado nuevo (para creates/updates)
  metadata     Json?     // Información adicional contextual

  // Timestamps
  createdAt    DateTime  @default(now())

  // Relaciones
  tournament   Tournament? @relation(fields: [tournamentId], references: [id], onDelete: Cascade)
  user         User        @relation(fields: [userId], references: [id])

  @@index([tournamentId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("tournament_logs")
}
